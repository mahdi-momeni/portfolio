---
template: post
title: اشتباهات رایج اپ های ری اکتی
shortTitle: اشتباهات رایج اپ های ری اکتی
slug: /blog/react-bestpract
date: 1402/04/05
thumbnail: ./static/logo.png
tags:
  - design-system
categories:
  - react
---

## 1. استفاده از UUID در سطح دیتا نه در سطح کامپوننت

اگر در سطح کامپوننت از  uuid استفاده کنید باعث میشه در re-render هم uuid جدید ساخته بشه و این باعث گیج شدن ری اکت میشه. چون react از روی key تغییرات رو پیدا میکنه و چون همشون عوض شده بنابراین همه آیتم هارو دوباره rerender میکنه٬ در صورتی که شاید لازم بود فقط یکی از اون ها تغییراتش توی درخت DOM اعمال بشه

**راه حل :** میتونید توی ساختار دیتاتون بزارید. حتی اگه دیتای که از سرویس میگرید ID  نداره اول این کارو انجام بدید و بعد loop بزنید

~~~javascript
      const fetchedData = [
        { id: uuidv4(), name: 'انگولو کانته' },
        { id: uuidv4(), name: 'اوسا غلام' },
      ];
~~~

## 2. برای هر کامپوننت یک پوشه بسازید

اینکار نیاز به تغییر رو در آینده کم میکنه. چیزهای زیادی میتونه توی یک پوشه کامپوننت قرار بگیره

- storybook
- test(unit,e2e)
- css
- type
- شاید هم translation و یا کلی چیز دیگه که فعلا نمیدونم

قرار دادن فایل های مرتبط داخل یک پوشه باعث منظم شدن پروژه میشه و همچنین معولا اگر مثلا پوشه type کلا یه جای دیگر باشد پریدن از یه جا به جای دیگر خیلی واضح نیست.



## 3. دیتا رو mutate نکنید

`mutate` کردن یعنی توی [refrence type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#objects)ها بیایم مقدار جدید رو مستقیم بدون تغییر refrence تغییر بدیم. مثلا :

~~~js
items.push(newItem);
~~~

توی مثال بالا ما داریم مستقیم یک مقدار از یک خونه رم رو به صورت مستقیم عوض میکنیم

بجاش باید آبجکت یا آرایه قبلی رو کپی کنیم. مثلا:

~~~js
const newItems = items.concat([newItem]);
~~~

**چرا ؟**

دلیلش اینه که side effect داره و توی موقعیت های concurrency میتونه مشکلات ایجاد کنه که پیدا کردن مشکل سخته. مثلا اگر دوتابع داریم و همزمان اجرا میشن و دیتا رو mutate میکنه٬ ترتیب اجراشون مهمه و میتونه مشکل ساز بشه.

